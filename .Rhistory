ng=2,
link="thresholds",
nwg=FALSE))
},seed=TRUE)
}
RUN2=lapply(par.run,FUN=value)
saveRDS(RUN1,here("Export","paraRUN1"))
RUN1=readRDS(here("Export","paraRUN1"))
library(here)
library(utils)
RUN1=readRDS(here("Export","paraRUN1"))
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
consensus=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
consensus_prob=function(j){
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,consensus(index.pair[1,],index.pair[2,]))%>%t()
return(cons.prob.dat)
}
T1=Sys.time()
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
library(here)
library(utils)
library(lcmm)
library(tidyr)
library(renv)
library(dplyr)
library(rlang)
library(LCTMtools)
library(here)
library(ellipsis)
RUN1=readRDS(here("Export","paraRUN1"))
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
consensus=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
consensus_prob=function(j){
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,consensus(index.pair[1,],index.pair[2,]))%>%t()
return(cons.prob.dat)
}
T1=Sys.time()
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
debug(consensus_prob)
T1=Sys.time()
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
predprob=RUN1[[j]]$`Predicted class membership`
predprob
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,consensus(index.pair[1,],index.pair[2,]))%>%t()
consensus(index.pair[1,],index.pair[2,])
consensus_prob=function(j){
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
consensus=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,consensus(index.pair[1,],index.pair[2,]))%>%t()
return(cons.prob.dat)
}
undebug(consensus_prob)
T1=Sys.time()
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
length(CONSPROB_ALL[[1]])
test=unlist(CONSPROB_ALL)
length(test)
length(CONSPROB_ALL[[1]])*5
head(CONSPROB_ALL)
head(CONSPROB_ALL[[1]])
consensus_prob=function(j){
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
consensus=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,consensus(index.pair[1,],index.pair[2,]))%>%t()%>%data.frame()
colnames(cons.prob.dat)=c("ID1","ID2","consensus.prob")
return(cons.prob.dat)
}
T1=Sys.time()
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
head(CONSPROB_ALL[[1]])
test=unlist(CONSPROB_ALL)%>%group_by(ID1,ID2)
head(test)
test=unlist(CONSPROB_ALL)%>%arrange(ID1,ID2)
?arrange()
test=unlist(CONSPROB_ALL)%>%dplyr::arrange(ID1,ID2)
typeof(test$ID1)
typeof(test$ID1)
str(test)
head(CONSPROB_ALL[[1]])
CONSPROB_ALL2=CONSPROB_ALL[[1]]
for (i in 2:length(CONSPROB_ALL)){
CONSPROB_ALL2=rbind(CONSPROB_ALL2,CONSPROB_ALL[[i]])
}
dim(CONSPROB_ALL2)
dim(CONSPROB_ALL[[1]])
dim(CONSPROB_ALL[[1]])*5
test=CONSPROB_ALL2%>%dplyr::arrange(ID1,ID2)
head(test)
x=test%>%subset(ID1<ID2)
dim(x)
x=test%>%subset(ID1>ID2)
dim(x)
x=test%>%subset(ID1==ID2)
dim(x)
consensus_prob=function(j){
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
consensus=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,consensus(index.pair[1,],index.pair[2,]))%>%t()%>%data.frame()
colnames(cons.prob.dat)=c("ID1","ID2","same.group.prob")
return(cons.prob.dat)
}
T1=Sys.time()
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
CONSPROB_ALL2=CONSPROB_ALL[[1]]
for (i in 2:length(CONSPROB_ALL)){
CONSPROB_ALL2=rbind(CONSPROB_ALL2,CONSPROB_ALL[[i]])
}
consensus_prob=function(j){
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
same.group.prob=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,same.group.prob(index.pair[1,],index.pair[2,]))%>%t()%>%data.frame()
colnames(cons.prob.dat)=c("ID1","ID2","same.group.prob")
return(cons.prob.dat)
}
T1=Sys.time()
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
CONSPROB_ALL2=CONSPROB_ALL[[1]]
for (i in 2:length(CONSPROB_ALL)){
CONSPROB_ALL2=rbind(CONSPROB_ALL2,CONSPROB_ALL[[i]])
}
head(CONSPROB_ALL2)
CONSPROB=CONSPROB_ALL2%>%dplyr::arrange(ID1,ID2)%>%group_by(ID1,ID2)%>%summarise(consensus_prob=mean(same.group.prob),N_per_pair=n())
head(CONSPROB)
dim(CONSPROB)
CONSPROB$N_per_pair%>%table()
debug(consensus_prob)
consensus_prob=function(j){
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
same.group.prob=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,same.group.prob(index.pair[1,],index.pair[2,]))%>%t()%>%data.frame()
colnames(cons.prob.dat)=c("ID1","ID2","same.group.prob")
return(cons.prob.dat)
}
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
consensus_prob=function(j){
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
same.group.prob=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,same.group.prob(index.pair[1,],index.pair[2,]))%>%t()%>%data.frame()
colnames(cons.prob.dat)=c("ID1","ID2","same.group.prob")
return(cons.prob.dat)
}
debug(consensus_prob)
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
same.group.prob=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
predprob=RUN1[[j]]$`Predicted class membership`
predprob
index=predprob$ID
index
index.pair=combn(1:length(index),2)
index.pair
index.pair[,1:10]
ID.pair=index[index.pair]%>%matrix(nrow=2)
ID.pair[,1:10]
index.pair[1,1:10]
index.pair[2,]
index.pair[2,1:10]
ID.pair[1:10]
ID.pair[,1:10]
undebug(consensus_prob)
cl=makeCluster(detectCores()-1)
CONSPROB_ALL=parLapply(1:length(RUN1),consensus_prob)
CONSPROB_ALL=parLapply(cl,1:length(RUN1),consensus_prob)
rm(list=ls())
library(here)
library(utils)
library(lcmm)
library(tidyr)
library(renv)
library(dplyr)
library(rlang)
library(LCTMtools)
library(here)
library(ellipsis)
RUN1=readRDS(here("Export","paraRUN1"))
cl=makeCluster(detectCores()-1)
clusterExport(cl,ls(),envir = environment())
CONSPROB_ALL=parLapply(cl,1:length(RUN1),consensus_prob)
stopCluster(cl)
consensus_prob=function(j){
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
same.group.prob=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,same.group.prob(index.pair[1,],index.pair[2,]))%>%t()%>%data.frame()
colnames(cons.prob.dat)=c("ID1","ID2","same.group.prob")
return(cons.prob.dat)
}
cl=makeCluster(detectCores()-1)
clusterExport(cl,ls(),envir = environment())
CONSPROB_ALL=parLapply(cl,1:length(RUN1),consensus_prob)
consensus_prob=function(j){
library(here)
library(utils)
library(tidyr)
library(dplyr)
library(rlang)
library(ellipsis)
locateprob=function(i){
return(as.matrix(predprob[i,-c(1,2)]))
}
same.group.prob=function(subject.i,subject.j){
X=ifelse(subject.i==subject.j,NA,
rowSums(locateprob(subject.i)*locateprob(subject.j)))
return(X)
}
predprob=RUN1[[j]]$`Predicted class membership`
index=predprob$ID
index.pair=combn(1:length(index),2)
ID.pair=index[index.pair]%>%matrix(nrow=2)
cons.prob.dat=rbind(ID.pair,same.group.prob(index.pair[1,],index.pair[2,]))%>%t()%>%data.frame()
colnames(cons.prob.dat)=c("ID1","ID2","same.group.prob")
return(cons.prob.dat)
}
cl=makeCluster(detectCores()-1)
clusterExport(cl,ls(),envir = environment())
CONSPROB_ALL=parLapply(cl,1:length(RUN1),consensus_prob)
stopCluster(cl)
CONSPROB_ALL2=CONSPROB_ALL[[1]]
for (i in 2:length(CONSPROB_ALL)){
CONSPROB_ALL2=rbind(CONSPROB_ALL2,CONSPROB_ALL[[i]])
}
T1=Sys.time()
CONSPROB=CONSPROB_ALL2%>%dplyr::arrange(ID1,ID2)%>%group_by(ID1,ID2)%>%summarise(consensus_prob=mean(same.group.prob),N_per_pair=n())
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
TD1
T1=Sys.time()
cl=makeCluster(detectCores()-1)
clusterExport(cl,ls(),envir = environment())
CONSPROB_ALL=parLapply(cl,1:length(RUN1),consensus_prob)
stopCluster(cl)
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
TD1
T1=Sys.time()
# cl=makeCluster(detectCores()-1)
# clusterExport(cl,ls(),envir = environment())
CONSPROB_ALL=Lapply(1:length(RUN1),consensus_prob)
T1=Sys.time()
# cl=makeCluster(detectCores()-1)
# clusterExport(cl,ls(),envir = environment())
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
# stopCluster(cl)
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
TD1
T1=Sys.time()
cl=makeCluster(5)
clusterExport(cl,ls(),envir = environment())
CONSPROB_ALL=parLapply(cl,1:length(RUN1),consensus_prob)
stopCluster(cl)
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
TD1
hist(CONSPROB)
head(CONSPROB)
hist(CONSPROB$consensus_prob)
Consensus.Probabilities=CONSPROB$consensus_prob
hist(Consensus.Probabilities)
T1=Sys.time()
# cl=makeCluster(detectCores()-1)
# clusterExport(cl,ls(),envir = environment())
# CONSPROB_ALL=parLapply(cl,1:length(RUN1),consensus_prob)
# stopCluster(cl)
CONSPROB_ALL=lapply(cl,1:length(RUN1),consensus_prob)
RUN1=readRDS(here("Export","paraRUN1"))
T1=Sys.time()
# cl=makeCluster(detectCores()-1)
# clusterExport(cl,ls(),envir = environment())
# CONSPROB_ALL=parLapply(cl,1:length(RUN1),consensus_prob)
# stopCluster(cl)
CONSPROB_ALL=lapply(1:length(RUN1),consensus_prob)
CONSPROB_ALL2=CONSPROB_ALL[[1]]
for (i in 2:length(CONSPROB_ALL)){
CONSPROB_ALL2=rbind(CONSPROB_ALL2,CONSPROB_ALL[[i]])
}
CONSPROB=CONSPROB_ALL2%>%dplyr::arrange(ID1,ID2)%>%
group_by(ID1,ID2)%>%
summarise(consensus_prob=mean(same.group.prob),N_per_pair=n())
T2=Sys.time()
TD1=difftime(T2,T1, units="mins")
Consensus.Probabilities=CONSPROB$consensus_prob
hist(Consensus.Probabilities)
#Implement iterative resampling and model fitting --------------------------------------------
source(here('Programs','HelperFunc_ConsensusGBTM.R'))
TD1
library(here)
library(utils)
library(lcmm)
library(tidyr)
library(renv)
library(dplyr)
library(rlang)
library(LCTMtools)
library(here)
library(ellipsis)
SP_wide=readRDS(here("./Export/SP_wide"))
selected_K=c(2,3)
#Import fitted GBTM model
# mod2=readRDS(here("./Export/GBTM_mods_rep20maxit10"))
# FitTab_rep20maxit10=GBTM_stat(mod) #pick k=3,4,5
#Implement iterative resampling and model fitting --------------------------------------------
source(here('Programs','HelperFunc_ConsensusGBTM.R'))
T1=Sys.time()
RUN1=list()
for (i in 1:5){
RUN1[[i]]=resamp.modelfit(inputdata = SP_wide,
iter=i,
rep = 20,
maxiter = 10,
m=lcmm(fixed=Protect~1+Week+I(Week^2),
random=~-1,
mixture=~1+Week+I(Week^2),
subject='ID',
ng=2,
link="thresholds",
nwg=FALSE))
}
3*3*3*2
13000/54
4000/54
rm(list=ls())
#install packages if needed -----------------------------------------------------
#install.packages("lcmm")
#install.packages('tidyr')
#install.packages('dplyr')
#install.packages("rlang")
#install.packages("devtools")
#renv::install("hlennon/LCTMtools")
#install.packages('here')
#install.packages('ellipsis')
#Restore relevant packages-------------------------------------------------------
# renv::dependencies()
# renv::snapshot()
renv::restore()
#load libraries -----------------------------------------------------------------
library(lcmm)
library(tidyr)
library(renv)
library(dplyr)
library(rlang)
library(LCTMtools)
library(here)
library(ellipsis)
#Import input data --------------------------------------------------------------
SeroProtect=read.delim(here("./Export/SeroProtect_4k.txt"),sep=",",header=FALSE)
#Import input data --------------------------------------------------------------
SeroProtect=read.delim(here("./Data/SeroProtect_4k.txt"),sep=",",header=FALSE)
colnames(SeroProtect)=c("ID",sapply(1:103, function(i){
paste0("Protect",i)
}))
SeroProtect=read.delim(here("./Data/SeroProtect_4k.txt"),sep=",",header=FALSE)
colnames(SeroProtect)=c("ID",sapply(1:103, function(i){
paste0("Protect",i)
}))
#Convert wide to long format
SP_long=SeroProtect%>%tidyr::gather(., Week, Protect,Protect1:Protect103, factor_key=TRUE)
SP_long$Week=gsub("Protect","",SP_long$Week)%>%as.numeric()
SP_long=SP_long%>%arrange(ID,Week)
##scale down the time variable to facilitate model convergence
SP_long$Week=SP_long$Week/10
saveRDS(SP_long,here("./Data/SP_long_4k"))
#Run 1-group latent class trajectory model
mod=list()
mod[[1]]=lcmm(Protect~1+Week+I(Week^2), subject='ID',ng=1,data=SP_long, link="thresholds", maxiter=200)
source(here("Programs","Helper_Functions_GBTM.R"))
num_rep=20
num_maxit=10
Time_rep20maxit10=rep(NA,6)
mod[[2]]=mod[[3]]=mod[[4]]=mod[[5]]=mod[[6]]=NULL
for (k in 2:6){
cat("K=",k)
t1=Sys.time()
cl=makeCluster(Ncore-1)
clusterExport(cl,list("k",'lcmm'),environment())
mod[[k]]=gridsearch(rep = num_rep, maxiter = num_maxit, minit = mod[[1]],
lcmm(fixed=Protect~1+Week+I(Week^2),random=~-1, mixture=~1+Week+I(Week^2),
subject='ID',ng=k,data=SP_long, link="thresholds",nwg=FALSE),cl=cl)
stopCluster(cl)
t2=Sys.time()
Time_rep20maxit10[k]=difftime(t2,t1,units ='mins')
}
num_rep=20
num_maxit=10
Ncore=detectCores()-1
Time_rep20maxit10=rep(NA,6)
mod[[2]]=mod[[3]]=mod[[4]]=mod[[5]]=mod[[6]]=NULL
for (k in 2:6){
cat("K=",k)
t1=Sys.time()
cl=makeCluster(Ncore-1)
clusterExport(cl,list("k",'lcmm'),environment())
mod[[k]]=gridsearch(rep = num_rep, maxiter = num_maxit, minit = mod[[1]],
lcmm(fixed=Protect~1+Week+I(Week^2),random=~-1, mixture=~1+Week+I(Week^2),
subject='ID',ng=k,data=SP_long, link="thresholds",nwg=FALSE),cl=cl)
stopCluster(cl)
t2=Sys.time()
Time_rep20maxit10[k]=difftime(t2,t1,units ='mins')
}
library(doParallel)
library(doSNOW)
library(future)
renv::restore()
renv::snapshot()
